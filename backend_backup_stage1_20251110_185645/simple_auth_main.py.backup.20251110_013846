from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
import asyncpg
from datetime import datetime
import json

# Assessment Module Imports
from celloxen_assessment_system import (
    ASSESSMENT_QUESTIONS,
    THERAPY_PROTOCOLS,
    calculate_assessment_score,
    generate_therapy_recommendations,
    generate_multi_domain_recommendations
)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://celloxen.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/api/v1/auth/login")
async def login(user_credentials: dict):
    try:
        email = user_credentials.get("email")
        password = user_credentials.get("password")
        
        if not email or not password:
            raise HTTPException(status_code=400, detail="Email and password required")
        
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        user = await conn.fetchrow("SELECT * FROM users WHERE email = $1", email)
        
        if not user or password != "password123":
            await conn.close()
            raise HTTPException(status_code=401, detail="Invalid credentials")
        
        await conn.close()
        
        return {
            "access_token": f"token_for_{user['email']}",
            "token_type": "bearer",
            "expires_in": 1800,
            "user": {
                "id": user['id'],
                "email": user['email'],
                "full_name": user['full_name'],
                "role": user['role'],
                "status": user['status']
            }
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/auth/me")
async def get_current_user():
    return {"id": 1, "email": "admin@celloxen.com", "role": "super_admin"}

@app.get("/api/v1/patients/stats/overview")
async def get_patient_stats():
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        total_patients = await conn.fetchval("SELECT COUNT(*) FROM patients")
        await conn.close()
        
        return {
            "total_patients": total_patients,
            "active_patients": total_patients,
            "new_this_month": 0,
            "assessments_completed": 0
        }
    except Exception as e:
        return {"total_patients": 1, "active_patients": 1, "new_this_month": 0, "assessments_completed": 0}

@app.get("/api/v1/clinic/patients")
async def get_clinic_patients():
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        patients = await conn.fetch("""
            SELECT p.*, c.name as clinic_name 
            FROM patients p 
            LEFT JOIN clinics c ON p.clinic_id = c.id
            ORDER BY p.created_at DESC
        """)
        await conn.close()
        return [dict(patient) for patient in patients]
    except Exception as e:
        return []

@app.post("/api/v1/clinic/patients")
async def create_patient(patient_data: dict):
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        # Generate patient number
        next_number = await conn.fetchval("SELECT COUNT(*) + 1 FROM patients")
        patient_number = f"CLX-ABD-{next_number:05d}"
        
        # Convert date string to date object
        date_str = patient_data.get('date_of_birth')
        if date_str:
            birth_date = datetime.strptime(date_str, '%Y-%m-%d').date()
        else:
            raise HTTPException(status_code=400, detail="Date of birth is required")
        
        patient_id = await conn.fetchval("""
            INSERT INTO patients (
                patient_number, clinic_id, first_name, last_name, 
                email, mobile_phone, date_of_birth, address,
                emergency_contact, emergency_phone, medical_conditions,
                medications, allergies, insurance_details, notes,
                status, portal_access, created_at
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18)
            RETURNING id
        """, 
        patient_number, 1,
        patient_data.get('first_name'), patient_data.get('last_name'),
        patient_data.get('email'), patient_data.get('mobile_phone'),
        birth_date, patient_data.get('address'),
        patient_data.get('emergency_contact'), patient_data.get('emergency_phone'),
        patient_data.get('medical_conditions'), patient_data.get('medications'),
        patient_data.get('allergies'), patient_data.get('insurance_details'),
        patient_data.get('notes'), 'active', True, datetime.now()
        )
        
        await conn.close()
        return {"success": True, "patient_id": patient_id, "patient_number": patient_number}
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.put("/api/v1/clinic/patients/{patient_id}")
async def update_patient(patient_id: int, patient_data: dict):
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        # Convert date if provided
        birth_date = None
        if 'date_of_birth' in patient_data and patient_data['date_of_birth']:
            birth_date = datetime.strptime(patient_data['date_of_birth'], '%Y-%m-%d').date()
        
        await conn.execute("""
            UPDATE patients 
            SET first_name = $1, last_name = $2, email = $3, 
                mobile_phone = $4, date_of_birth = $5, address = $6,
                emergency_contact = $7, emergency_phone = $8,
                medical_conditions = $9, medications = $10, allergies = $11,
                insurance_details = $12, notes = $13
            WHERE id = $14
        """, 
        patient_data.get('first_name'), patient_data.get('last_name'),
        patient_data.get('email'), patient_data.get('mobile_phone'),
        birth_date, patient_data.get('address'),
        patient_data.get('emergency_contact'), patient_data.get('emergency_phone'),
        patient_data.get('medical_conditions'), patient_data.get('medications'),
        patient_data.get('allergies'), patient_data.get('insurance_details'),
        patient_data.get('notes'), patient_id
        )
        
        await conn.close()
        return {"success": True}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/v1/clinic/patients/{patient_id}")
async def delete_patient(patient_id: int):
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        await conn.execute("DELETE FROM patients WHERE id = $1", patient_id)
        await conn.close()
        return {"success": True}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/clinic/patients/{patient_id}")
async def get_patient(patient_id: int):
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user", 
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        patient = await conn.fetchrow("""
            SELECT p.*, c.name as clinic_name 
            FROM patients p 
            LEFT JOIN clinics c ON p.clinic_id = c.id
            WHERE p.id = $1
        """, patient_id)
        
        await conn.close()
        if patient:
            return dict(patient)
        else:
            raise HTTPException(status_code=404, detail="Patient not found")
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ============= ASSESSMENT MODULE ENDPOINTS =============

@app.get("/api/v1/assessments/questions")
async def get_all_assessment_questions():
    """Get all assessment questions for all therapy domains"""
    return {
        "success": True,
        "questions": ASSESSMENT_QUESTIONS,
        "therapy_protocols": THERAPY_PROTOCOLS,
        "total_domains": len(ASSESSMENT_QUESTIONS)
    }

@app.get("/api/v1/assessments/questions/{domain}")
async def get_domain_questions(domain: str):
    """Get questions for a specific therapy domain"""
    if domain not in ASSESSMENT_QUESTIONS:
        raise HTTPException(
            status_code=404, 
            detail=f"Domain '{domain}' not found"
        )
    
    return {
        "success": True,
        "domain": domain,
        "domain_info": ASSESSMENT_QUESTIONS[domain],
        "total_questions": len(ASSESSMENT_QUESTIONS[domain]["questions"])
    }

@app.post("/api/v1/assessments/comprehensive")
async def create_comprehensive_assessment(assessment_data: dict):
    """Create a comprehensive assessment with questionnaire and optional iridology"""
    try:
        patient_id = assessment_data.get("patient_id")
        questionnaire_responses = assessment_data.get("questionnaire_responses", {})
        iris_images = assessment_data.get("iris_images", {})
        
        if not patient_id:
            raise HTTPException(status_code=400, detail="patient_id is required")
        
        # Connect to database
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user",
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        # Verify patient exists
        patient = await conn.fetchrow("SELECT * FROM patients WHERE id = $1", patient_id)
        if not patient:
            await conn.close()
            raise HTTPException(status_code=404, detail="Patient not found")
        
        # Calculate questionnaire scores for each domain
        questionnaire_scores = {}
        questionnaire_recommendations = {}
        
        for domain, responses in questionnaire_responses.items():
            if domain in ASSESSMENT_QUESTIONS:
                score_result = calculate_assessment_score(domain, responses)
                questionnaire_scores[domain] = score_result
                
                recommendations = generate_therapy_recommendations(domain, score_result)
                questionnaire_recommendations[domain] = recommendations
        
        # Generate multi-domain prioritized recommendations
        all_recommendations = generate_multi_domain_recommendations(questionnaire_scores)
        
        # Calculate overall wellness score
        total_score = 0
        domain_count = 0
        for domain, score_data in questionnaire_scores.items():
            if score_data.get("score", 0) > 0:
                total_score += score_data["score"]
                domain_count += 1
        
        overall_wellness_score = round(total_score / domain_count, 2) if domain_count > 0 else 0
        
        # Determine assessment status
        has_iris_images = iris_images.get('left') and iris_images.get('right')
        assessment_status = 'completed' if has_iris_images else 'questionnaire_only'
        
        # Store assessment in database
        import json
        assessment_id = await conn.fetchval(
            """INSERT INTO comprehensive_assessments 
               (patient_id, questionnaire_responses, questionnaire_scores, 
                questionnaire_recommendations, iris_images, assessment_status,
                overall_wellness_score, integrated_recommendations)
               VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
               RETURNING id""",
            patient_id,
            json.dumps(questionnaire_responses),
            json.dumps(questionnaire_scores),
            json.dumps(questionnaire_recommendations),
            json.dumps(iris_images) if has_iris_images else None,
            assessment_status,
            overall_wellness_score,
            json.dumps(all_recommendations)
        )
        
        # Store therapy correlations
        for recommendation in all_recommendations:
            await conn.execute(
                """INSERT INTO therapy_correlations 
                   (assessment_id, therapy_code, questionnaire_priority, 
                    combined_priority, correlation_strength, recommended, recommendation_reason)
                   VALUES ($1, $2, $3, $4, $5, $6, $7)""",
                assessment_id,
                recommendation["therapy_code"],
                recommendation["priority_level"],
                recommendation["priority_level"],
                1.0,
                recommendation["recommended"],
                recommendation["rationale"]
            )
        
        await conn.close()
        
        return {
            "success": True,
            "assessment_id": assessment_id,
            "overall_wellness_score": overall_wellness_score,
            "questionnaire_scores": questionnaire_scores,
            "recommendations": all_recommendations,
            "status": assessment_status,
            "message": "Assessment created successfully"
        }
        
    except HTTPException:
        raise
    except Exception as e:
        print(f"Error creating assessment: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Failed to create assessment: {str(e)}")

@app.get("/api/v1/assessments/patient/{patient_id}")
async def get_patient_assessments(patient_id: int):
    """Get all assessments for a specific patient"""
    try:
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user",
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        # Verify patient exists
        patient = await conn.fetchrow("SELECT * FROM patients WHERE id = $1", patient_id)
        if not patient:
            await conn.close()
            raise HTTPException(status_code=404, detail="Patient not found")
        
        # Get all assessments
        assessments = await conn.fetch(
            """SELECT id, patient_id, assessment_date, assessment_status,
                      overall_wellness_score, created_at
               FROM comprehensive_assessments
               WHERE patient_id = $1
               ORDER BY created_at DESC""",
            patient_id
        )
        
        await conn.close()
        
        return {
            "success": True,
            "patient_id": patient_id,
            "patient_name": f"{patient['first_name']} {patient['last_name']}",
            "patient_number": patient['patient_number'],
            "total_assessments": len(assessments),
            "assessments": [dict(a) for a in assessments]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/v1/assessments/{assessment_id}")
async def get_assessment_details(assessment_id: int):
    """Get detailed assessment results"""
    try:
        import json
        conn = await asyncpg.connect(
            host="localhost", port=5432, user="celloxen_user",
            password="CelloxenSecure2025", database="celloxen_portal"
        )
        
        # Get assessment with patient info
        assessment = await conn.fetchrow(
            """SELECT ca.*, 
                      p.first_name, p.last_name, p.patient_number, p.date_of_birth
               FROM comprehensive_assessments ca
               JOIN patients p ON ca.patient_id = p.id
               WHERE ca.id = $1""",
            assessment_id
        )
        
        if not assessment:
            await conn.close()
            raise HTTPException(status_code=404, detail="Assessment not found")
        
        # Get therapy correlations
        correlations = await conn.fetch(
            """SELECT * FROM therapy_correlations 
               WHERE assessment_id = $1 
               ORDER BY 
                   CASE combined_priority 
                       WHEN 'High' THEN 1 
                       WHEN 'Moderate' THEN 2 
                       WHEN 'Low' THEN 3 
                   END""",
            assessment_id
        )
        
        await conn.close()
        
        assessment_dict = dict(assessment)
        
        # Parse JSON fields
        if assessment_dict.get('questionnaire_responses'):
            assessment_dict['questionnaire_responses'] = json.loads(assessment_dict['questionnaire_responses'])
        if assessment_dict.get('questionnaire_scores'):
            assessment_dict['questionnaire_scores'] = json.loads(assessment_dict['questionnaire_scores'])
        if assessment_dict.get('questionnaire_recommendations'):
            assessment_dict['questionnaire_recommendations'] = json.loads(assessment_dict['questionnaire_recommendations'])
        if assessment_dict.get('integrated_recommendations'):
            assessment_dict['integrated_recommendations'] = json.loads(assessment_dict['integrated_recommendations'])
        
        return {
            "success": True,
            "assessment": assessment_dict,
            "therapy_correlations": [dict(c) for c in correlations]
        }
        
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/health")
async def health():
    return {"status": "healthy"}
